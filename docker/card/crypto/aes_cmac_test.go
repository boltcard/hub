package crypto

import (
	"crypto/aes"
	"testing"

	"github.com/aead/cmac"
)

// generateTestCmac produces the expected 8-byte truncated CMAC for a given key and sv2,
// following the same algorithm as Aes_cmac: derive session key via CMAC(key, sv2),
// then compute CMAC({}, session_key) and pick odd-indexed bytes.
func generateTestCmac(key, sv2 []byte) []byte {
	c2, _ := aes.NewCipher(key)
	ks, _ := cmac.Sum(sv2, c2, 16)
	c3, _ := aes.NewCipher(ks)
	cm, _ := cmac.Sum([]byte{}, c3, 16)
	ct := make([]byte, 8)
	ct[0] = cm[1]
	ct[1] = cm[3]
	ct[2] = cm[5]
	ct[3] = cm[7]
	ct[4] = cm[9]
	ct[5] = cm[11]
	ct[6] = cm[13]
	ct[7] = cm[15]
	return ct
}

func TestAesCmac_ValidMac(t *testing.T) {
	key := []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}
	sv2 := []byte{0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}

	expected := generateTestCmac(key, sv2)

	result, err := Aes_cmac(key, sv2, expected)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if !result {
		t.Fatal("expected CMAC to match, got false")
	}
}

func TestAesCmac_InvalidMac(t *testing.T) {
	key := []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}
	sv2 := []byte{0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}

	wrongMac := []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}

	result, err := Aes_cmac(key, sv2, wrongMac)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result {
		t.Fatal("expected CMAC mismatch, got true")
	}
}

func TestAesCmac_WrongKeyLength(t *testing.T) {
	badKey := []byte{0x00, 0x01, 0x02} // too short
	sv2 := []byte{0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}
	mac := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

	_, err := Aes_cmac(badKey, sv2, mac)
	if err == nil {
		t.Fatal("expected error for invalid key length")
	}
}

func TestAesCmac_DifferentKeysProduceDifferentResults(t *testing.T) {
	key1 := []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}
	key2 := []byte{0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
		0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff}
	sv2 := []byte{0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}

	mac1 := generateTestCmac(key1, sv2)

	// mac1 should not validate with key2
	result, err := Aes_cmac(key2, sv2, mac1)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result {
		t.Fatal("expected CMAC mismatch with different key")
	}
}
